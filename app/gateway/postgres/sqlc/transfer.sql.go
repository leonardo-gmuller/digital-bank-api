// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: transfer.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createTransfer = `-- name: CreateTransfer :exec
INSERT INTO transfer (account_destination_id, account_origin_id, amount) 
VALUES ($1, $2, $3)
`

type CreateTransferParams struct {
	AccountDestinationID int64
	AccountOriginID      int64
	Amount               int32
}

func (q *Queries) CreateTransfer(ctx context.Context, arg CreateTransferParams) error {
	_, err := q.db.Exec(ctx, createTransfer, arg.AccountDestinationID, arg.AccountOriginID, arg.Amount)
	return err
}

const listTransfer = `-- name: ListTransfer :many
SELECT account.cpf as account_destination_cpf, amount, transfer.created_at FROM transfer
JOIN account ON account.id = account_destination_id
WHERE account_origin_id = $1
AND transfer.deleted_at IS NULL
`

type ListTransferRow struct {
	AccountDestinationCpf string
	Amount                int32
	CreatedAt             pgtype.Timestamptz
}

func (q *Queries) ListTransfer(ctx context.Context, accountOriginID int64) ([]ListTransferRow, error) {
	rows, err := q.db.Query(ctx, listTransfer, accountOriginID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTransferRow
	for rows.Next() {
		var i ListTransferRow
		if err := rows.Scan(&i.AccountDestinationCpf, &i.Amount, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
